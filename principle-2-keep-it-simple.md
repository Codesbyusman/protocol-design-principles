# Principle 2: Keep it simple

Ease of use is a virtue - designs that enable users to operate securely with minimal intervention (or technical knowledge) make a vast difference to the security of many ordinary users. Protocol designs that are simple to implement and use previously established components can allow for easier evolution and avoid vulnerabilities that arise from design complexity.

## 2.1 Avoid design and deployment complexity

Vulnerabilities often arise due to complexity in both products and protocols. Designers should aim to avoid unnecessary complexity, so the protocol can be well understood at design time, modelled, and receive a full security analysis. Open review is a crucial part of the protocol design process, allowing issues to be found and addressed before they cause issues for either implementers or users. Taking design decisions that allow for easy, open review, by limiting complex logic, therefore builds both the security and confidence in the security of the protocol.

Protocols should also be designed to allow for simple implementations that reduce the risk of non-deterministic states and scope for errors at implementation time. Simple implementations made possible by the protocol design, such as those with modularisation or code re-use, enable meaningful analysis and reduce the scope for complex code with opaque justifications. Designing protocols to build on existing mechanisms, such as hardware roots of trust, can also reduce implementation complexity. Providing lots of intricate configuration options or modes of operation can make designs more complicated and much harder to test – prioritise the use case when deciding which options and modes are necessary. Limiting options and modes makes it easier to verify that the protocol has the claimed protections against its threat model, ensuring the user has the security they need.

Complexity is to be avoided in deployment of protocols too. Overly complicated, or ill-defined, methods of deployment for a protocol mean it is more likely to be deployed incorrectly or not deployed at all. Interoperability is an important property of protocols that can be impacted if deployment is not done well. While not an inherent part of protocol design, deployment is heavily influenced by protocol design decisions, and should therefore be considered during that process. A secure protocol must be deployed securely to protect user privacy.

## 2.2 Make it easy to use securely

Most users don’t know how the internet works or what protocols they’re using, and nor should they need to. They want to use products or services, not configure them. Default settings should be configured in a way that balances user needs with security. This means that users should have secure choices made for them by default. Further, these defaults do not obstruct a user from being protected by other common security measures and do not allow an attacker to disable such choices easily. Sensible defaults will help users improve privacy of communications and protect endpoints from compromise.

Protocols are also often designed with security built-in, but without user-centric security in mind. This can result in protocols that lead users to misunderstand the security they're getting, be it belief in the identity of the 'From' field in an email, or the level of trust they should place in an 'https' website. It's also common for protocols to be designed with the assumption that all users are equivalent, and have the same security, privacy, understanding of threats, and safety needs and wants, but, in reality, users vary greatly, with very different levels of vulnerability to different types of threats.

Protocols should be designed with users and deployment models in mind, such that they meet users’ basic security expectations by default and allow for those with more specific requirements to be catered for.

## 2.3 Don’t reinvent the wheel

Use existing, tested and well-established technologies where possible. Using proven building blocks makes it easier to have confidence in the constituent parts of a protocol. Not only will security analyses likely exist for those standard components already, but so will tried and trusted implementations. While use of existing components is no guarantee of security, making things easier for implementers, by facilitating use of well-tested libraries, is more likely to result in secure implementations. A prime example of not reinventing the wheel is to use standard, well-understood cryptography in protocols. If an algorithm has been in wide use, and has robust implementations available, it is less likely to:
* have any undiscovered security flaws
* be implemented incorrectly (when compared to a bespoke implementation of a new algorithm)

A good example of this is authentication - a key component of secure communication. Many good authentication solutions already exist, so where a protocol implements its own authentication, it could be taking extra risks. Techniques like single sign-on (SSO) allow a protocol to use an existing, robust authentication method. Clearly it is important to consider the use case and use a method that is operating to a similar threat model to the protocol being designed; using an established but inappropriate method may introduce (rather than reduce) weakness.

## 2.4 Design for easy maintenance and upgrades

Patching is important; it prevents systems remaining vulnerable to old attacks that should no longer be effective. Patching needs to be made simple or many admins won’t have the time (or inclination) to do it. A non-savvy user can’t be expected to make a sensible choice between a seemingly small chance of compromise and a convoluted update process or a compatibility-constraining patch. For critical systems that cannot afford any down time, a protocol that is not easy to patch or maintain can become insecure as operational priorities may override security considerations.

Protocols will often be used in ways not anticipated by their original use case - if there is a way to provide support for new use cases through easy extensibility, this is usually valuable. When extending a protocol, any new use cases must be compatible with the original threat model to ensure that security guarantees are maintained. Providing simple extensibility and flexibility in the design from the beginning can boost security by protecting against insecure use of the protocol or the need for workarounds that are inconvenient or inefficient. Well-designed extensibility can also remove the need for patches that damage interoperability and prevent deployers needing to switch to a whole new protocol – helping to promote a healthy ecosystem.

While implementation of patches is beyond the scope of protocol design, patching can be made easier in a range of ways. One way is to keep the protocol design simple, which reduces the likelihood of ossification (loss of extensibility through inextensible implementations), therefore making it easier for different versions to interoperate, removing a risk of patching. Stateless designs not only usually make for easier implementation, but also, along with designs that enable load-balancing or handing off responsibility, make it easier to patch servers without having to incur downtime.

Allowing for easy patches and updates also allows for ‘crypto-agility’ (updating and replacing cryptographic algorithms used within the protocol). If implementations of a protocol are hard to update, then making a change to the protocol design through patching is likely to be ineffective or even harmful to security. It could lead to the protocol’s ecosystem splintering with inconsistent security guarantees between different users, compromising the privacy of all users, including those who upgraded. Designing the protocol in such a way that adding a new algorithm, or deprecating an old one, is a simple change will help its implementations, and the ecosystem it operates in, to stay secure.
